<h1 id="pageTitle">Design</h1>
<h1>Basic Proxy</h1>
<h1>On-demand Packages</h1>
<h2>"Demand" Command</h2>
<h2>Internet Downloads</h2>
<h2>Node Packages</h2>
<h1>Pub-Sub Support</h1>
<h1>Save Files</h1>
<h1>Seamless Installation</h1>
<h2>Linux Installation</h2>
<h2>OS X Installation</h2>
<p>OS X installation involves downloading a single script and running it. In turn Roaster, Node are downloaded. Other
  dependencies download the first time roaster is run.
</p><h3>Installation Script</h3>
<pre class='gwt'>
 Given n OS X operating system
 and Internet access
 and that we are working with a file called 'roaster-unix-install.sh'
 in a temporary directory ending in 'roaster'

 When we download from github project 'uSDLC/roaster' at 'master/release'

 Then the file exists
</pre>
<h3>Install Roaster</h3>
<pre class='gwt'>
Given an OS X operating system
and Internet access
and that we are working with a file called 'roaster-unix-install.sh'
in a temporary directory ending in 'roaster'

if the file does not exist
 we download from github project 'uSDLC/roaster' at 'master/release'

When we run 'roaster-unix-install.sh . no-go'

Then we confirm a file 'go' now exists
</pre>
<h3>Install Node</h3>
<pre class="gwt">
A Unix operating system
and Internet access
and that we are working with a file called 'go'
in a temporary directory ending in 'roaster'

if the file does not exist
 we download from github project 'uSDLC/roaster' at 'master/release'

When we run '/bin/bash go pwd'

Then a file 'ext/node/bin/node' now exists
</pre>
<h3>Install Modules</h3>
<pre class="gwt">
Given a Unix operating system
and Internet access
and that we are working with a file called 'go'
in a temporary directory ending in 'roaster'

if the file does not exist
 we download from github project 'uSDLC/roaster' at 'master/release'

When we run '/bin/bash go update'

Then and confirm a file 'ext/node_modules/coffee-script/README' now exists
</pre>
<h3>Instrumentation</h3>
<pre class='coffee closed'>
       require '../Instrumentation.coffee'
     </pre>
<h2>Windows Installation</h2>
<h2>Instrumentation</h2>
<pre class='coffee closed'>
gwt = global.gwt # set by uSDLC2/scripts/gwt

# Module requirements
internet = require('internet')(); processes = require('processes')
path = require('path'); os = require('system'); fs = require('file-system')

# Common variable across instrumentation
file_name = ''
temp_directory = ''
file_path = -> path.join temp_directory, file_name

gwt.rules( # Rules used by child pages
  /An? (.+) operating system/, (system) ->
    @skip.section("not running on #{system}") if not os.expecting(system)
    @next()

  /Internet access/, ->
    internet.available (error) =>
      @skip.section("Internet not available") if error
      @next()

  /working with a file called '(.*)'/, (all, name) ->
    file_name = name
    @next()

  /in a temporary directory ending in '(.*)'/, (ending) ->
    console.log temp_directory = path.join os.tmpDir(), ending
    fs.mkdir temp_directory, @next

  /download from github project '(.*)' at '(.*)'/, (project, at) ->
    @maximum_step_time = 120
    internet.download.to(file_path()).
      from "https://raw.github.com/#{project}/#{at}/#{file_name}", @next

  /file exists/, ->
    fs.exists file_path(), (exists) =>
      @next(@error "#{file_path()} expected, but does not exist" if not exists)

  /run '(.*)'/, (command_line) ->
    fs.in_directory temp_directory, =>
      processes().cmd command_line, @next

  /if the file does not exist/, ->
    fs.exists file_path(), (exists) =>
      @skip.statements() if exists
      @next()

  /and confirm a file '(.*)' now exists/, (name) ->
    fs.exists path.join(temp_directory, name), (exists) =>
      throw "#{name} expected to exist" if not exists
      @next()

  /download from github project '(.*)'/, (project) ->
    projectName = project.split('/').pop()
    temp_directory = path.join os.tmpDir(), projectName
    fs.mkdir temp_directory, =>
      old_file_name = file_name
      file_name = 'install-usdlc-on-unix.sh'
      at = 'master/release'
      internet.download.to(file_path()).
      from "https://raw.github.com/#{project}/#{at}/#{file_name}", =>
        instrument.in_directory temp_directory, =>
          processes().cmd file_path(), '.', 'no-go', =>
            file_name = old_file_name
            @next()
)
</pre>
<h1>Serve Static Files</h1>
<h1>Scripts</h1>
<h2>Process Control</h2>
Roaster extends the node child_process module.
<pre class='coffee'>
processes = require 'processes'
my_program = processes('my_program')
</pre>
<p>Once you have a program, it can be run quickly as a separate node process, spawned to run as a separate program or
  run under the operating system shell. In addition you can set the program up to restart every time it exits or
  crashes, send it signals, communicate with it and work with input and output.</p>
<h3>Node Processes</h3>
<p>
  Node is single-threaded. If you have intensive CPU work to do it makes sense to start a separate node process that
  will possibly work on a different CPU. Node provides a bidirectional communication channel between the processes. The
  Node manual states that a new process will take about 30ms and use 10Mb of memory.
</p>
<pre class='coffee'>
processes = require 'processes'
sample_script = processes('Sample_Script').node -> console.log 'sample process complete'
sample_script.send '5'
sample_script.on 'message', (message) ->
  global.tap.check -> if message is {result: 50}
</pre>
<h4>Sample Script</h4>
<pre class='coffee'>
module.exports = (args...) ->
  process.on 'message', (message) ->
    process.send result: +message * 10
    process.exit(0) # a node process does not exit until commanded
</pre>
